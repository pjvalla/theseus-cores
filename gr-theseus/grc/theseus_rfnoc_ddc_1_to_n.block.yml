# auto-generated by grc.converter

id: theseus_rfnoc_ddc_1_to_n
label: 'RFNoC: DDC 1-to-N'

parameters:
-   id: num_chans
    label: Num Channels
    dtype: int
    default: '1'
    hide: part
-   id: input_rate
    label: Input Rate
    dtype: real
    default: samp_rate
-   id: enable_chans
    label: Enable Channels
    dtype: int_vector
    default: '[0]'
-   id: output_rate
    label: Output Rate List
    dtype: real_vector
    default: '[samp_rate]'
-   id: freq
    label: Frequency List
    dtype: real_vector
    default: '[0.0]'
-   id: fullscale
    label: Full scale
    category: Advanced
    dtype: real
    default: '1.0'
    hide: part
-   id: type
    label: Host Data Type
    dtype: enum
    options: [fc32, sc16]
    option_labels: [Complex float32, Complex int16]
    option_attributes:
        type: [complex, sc16]
    hide: part
-   id: otw
    label: Device Format
    dtype: enum
    options: [sc16]
    option_labels: [Complex int16]
-   id: block_index
    label: Block Select
    category: RFNoC Config
    dtype: int
    default: '-1'
    hide: ${ ('part' if int(block_index) < 0 else 'none') }
-   id: device_index
    label: Device Select
    category: RFNoC Config
    dtype: int
    default: '-1'
    hide: ${ ('part' if int(device_index) < 0 else 'none') }
-   id: fpga_module_name
    label: FPGA Module Name
    category: RFNoC Config
    dtype: string
    default: noc_block_ddc_1_to_n
    hide: all
-   id: grvlen
    label: Force Vector Length
    dtype: int
    default: '1'
    hide: ${ 'part' if grvlen == 1 else 'none' }

inputs:
-   domain: stream
    dtype: ${ type.type }
    vlen: ${ grvlen }
    multiplicity: '1'

outputs:
-   domain: stream
    dtype: ${ type.type }
    vlen: ${ grvlen }
    multiplicity: ${ num_chans }
asserts:
- ${ num_chans == len(enable_chans) }
- ${ num_chans == len(output_rate) }
- ${ num_chans == len(freq) }

templates:
    imports: import theseus
    make: |
        ettus.rfnoc_generic(
            self.device3,
            uhd.stream_args( \# TX Stream Args
                cpu_format="$type",
                otw_format="$otw",
                args="input_rate={},fullscale={}".format(${input_rate}, ${fullscale}),
            ),
            uhd.stream_args( \# RX Stream Args
                cpu_format="$type",
                otw_format="$otw",
                args="",
            ),
            "DDC1TON", ${block_index}, ${device_index},
        )
        self.${id}.set_arg("input_rate", float(${input_rate}), 0)
        for ichan, ion, irate, ifreq  in zip(xrange(${num_chans}), ${enable_chans}, ${output_rate}, ${freq}):
            if ion:
                self.${id}.set_arg("output_rate", float(irate), ichan)
                self.${id}.set_arg("fullscale", ${fullscale}, ichan)
                self.${id}.set_arg("freq", ifreq, ichan)
                self.${id}.set_arg("enable", 1, ichan)
            else:
                self.${id}.set_arg("enable", 0, ichan)
    callbacks:
    - set_arg("input_rate", float(${input_rate}))
    - "for i, rate in zip(xrange(${num_chans}), ${output_rate}):\n    self.${id}.set_arg(\"\
        output_rate\", float(rate), i)"
    - "for i, freq in zip(xrange(${num_chans}), ${freq}):\n    self.${id}.set_arg(\"\
        freq\", freq, i)"

file_format: 1
